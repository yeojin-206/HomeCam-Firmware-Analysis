# 펌웨어 추출 백업

---

# 2.1 SPI 기반 펌웨어 추출 (Raspberry Pi 사용)

- [ ]  칩 데이터 시트 확보
- [ ]  chip-off  (필요 시)
- [ ]  GND / CS / CLK / DO / DI / VCC 6 핀 배선 확인
- [ ]  Raspberry Pi 4 전원 연결
- [ ]  SPI 인터페이스 활성화
- [ ]  flashrom  빌드 / 설치 완료

## 2.1.1 개요

SPI NOR Flash에서 펌웨어를 추출하기 위해 Raspberry Pi와 flashrom 도구를 사용했다. 플래시 칩을 라즈베리파이에 직접 연결한 뒤, flashrom을 통해 전체 덤프 파일을 생성하는 방식이다. 

## 2.1.2 준비물

| 항목 | 설명 |
| --- | --- |
| Raspberry Pi 4 | SPI 통신 및 GPIO 핀 제공 |
| 점퍼 케이블 | Flash 칩 ↔ Pi 연결용 |
| XM25QH64C (SPI NOR Flash) | 8핀, 8MB 용량 |
| flashrom | 오픈소스 플래시 추출 도구 |

![Raspberry Pi 4](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%206.png)

Raspberry Pi 4

![점퍼 케이블](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%207.png)

점퍼 케이블

## 2.1.3 Chip-Off

기판에 Flash memory가 장착된 상태에서 직접 SPI로 연결하기 어려운 상황(간섭, 납땜 품질 저하 등)을 고려해, flash chip을 직접 탈착하여 펌웨어를 추출하는 chip-off 방식을 사용했다.

- 사용한 장비 및 준비물
    
    
    | 장비 / 재료 | 용도 및 설명 |
    | --- | --- |
    | 캡톤 테이프 (Kapton Tape) | SoC, 콘덴서, 저항 등의 주변 부품이 열에 손상되지 않도록 보호 |
    | 납땜 워크 스페이스 (작업 매트 포함) | 정전기 방지 매트와 내열 작업 공간 확보 |
    | 솔더 페이스트 (Solder Paste) | 납 흡착을 돕고 열 전달을 균일하게 해줌 |
    | 열풍기 (Hot Air Rework Station) | 칩에 열을 가해 납을 녹이고 안전하게 칩 분리 수행 |
    | 인두기 (Soldering Iron) | 납 보충, 핀 리워크, 마무리 정리용으로 사용 |
    | 납 제거기 (Solder Sucker) | 납 제거를 위해 사용. 패드 손상 없이 잔여 납을 흡입함 |

- 진행 과정

![캡톤 테이프로 칩 주변 부품 보호](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%202.png)

캡톤 테이프로 칩 주변 부품 보호

![솔더 페이스트와 열풍기](%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2022f1e282ea1580498c93f443493ddb7b/image.png)

솔더 페이스트와 열풍기

칩을 분리하기에 앞서, 기판 위의 SoC 및 주변 부품이 고온에 의해 손상되지 않도록 캡톤 테이프로 보호하였다. 

flash 메모리 탈착은 납땜 워크 스페이스에서 열풍기와 솔더 페이스트를 활용해 진행하였다. 칩 하단에 적당량의 페이스트를 도포한 후, 열풍기로 일정한 열을 가해 납을 녹이고 칩을 조심스럽게 들어올렸다.

![열풍기로 flashmemroy 분리하는 모습](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%204.png)

열풍기로 flashmemroy 분리하는 모습

![flash memory를 칩에서 분리한 모습](%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2022f1e282ea1580498c93f443493ddb7b/image_(3).png)

flash memory를 칩에서 분리한 모습

flash 메모리를 성공적으로 분리한 이후, 해당 칩을 별도의 SPI 연결 환경 (라즈베리 파이를 이용하여 flashrom 사용)을 통해 덤프할 수 있다. 이후 과정은 다음 절에서 설명한다.

## 2.1.4 라즈베리파이 GPIO 핀 연결 구성

XM25QH64C의 데이터시트를 참고하여 아래와 같이 라즈베리파이 GPIO 핀과 점퍼 케이블로 직접 연결했다. SOIC 클립은 사용하지 않고, 플래시 칩 핀에 납땜된 케이블을 연결했다.

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/c9601d58-a51e-40e0-bb8b-7bdbf2281024.png)

- 연결 구성

GPIO 헤더에 다음과 같이 연결해준다.

| Flash 핀 | 기능 | Pi 핀 번호 | GPIO 번호 | 설명 |
| --- | --- | --- | --- | --- |
| VCC | 전원 입력 | 1번 | — | 반드시 3.3V 사용  |
| GND | 접지 | 6번 | — | 접지 기준 전압 |
| /CS | 칩 선택 | 24번 | GPIO 8 | SPI 칩 선택 (Low 활성화) |
| CLK | 클럭 | 23번 | GPIO 11 | SPI 통신 속도 제어 신호 |
| DO | 데이터 출력 | 21번 | GPIO 9 | Flash → Pi (MISO) |
| DI | 데이터 입력 | 19번 | GPIO 10 | Pi → Flash |

먼저 /CS 핀(GPIO 8, 24번 핀)을 기준으로 잡고 나머지를 연결하면 실수가 줄어든다. 
점퍼선은 브레드보드에서 헐거워질 수 있으므로 전원 인가 전후로 한 번씩 물리적으로 다시 확인하는 것을 추천한다.

![스크린샷 2025-07-11 163208.png](%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2022f1e282ea1580498c93f443493ddb7b/6e8e2600-bc31-4677-a56d-5d7787b0d874.png)

사진은 Raspberry Pi 4와 SPI Flash 칩(XM25QH64C)을 브레드보드에 연결한 실습 장면이다.

각 점퍼 케이블은 데이터시트를 참고해 GPIO 핀에 정확히 연결되었으며, WP와 HOLD 핀은 VCC에 묶어 비활성화 상태로 설정하였다.

## 2.1.5 SPI 인터페이스 활성화

라즈베리파이에서 SPI 기능을 사용하기 위해 다음과 같이 인터페이스를 활성화한다.

```bash
sudo raspi-config
# → Interface Options → SPI → Enable
```

활성화 후 재부팅하고, SPI 모듈이 로드되었는지 확인한다:

```bash
lsmod | grep spi
```

정상적으로 연결이 되면 다음과 같은 출력이 된다.

```bash
spi_bcm2835     20480  0
spidev          20480  0
```

## 2.1.6 flashrom 설치

[https://github.com/flashrom/flashrom](https://github.com/flashrom/flashrom)

flashrom은 다양한 종류의 플래시 칩을 인식하고, 읽고/쓰기, 검증 등 할 수 있는 유틸리티이다. 

다음 명령어를 통해 flashrom 사용 환경을 세팅한다.

```bash
sudo apt-get install -y gcc meson ninja-build pkg-config python3-sphinx libcmocka-dev libpci-dev libusb-1.0-0-dev libftdi1-dev libjaylink-dev libssl-dev
git clone https://github.com/flashrom/flashrom
meson setup build
meson compile -C build
meson test -C builddir
sudo meson install -C build  
```

## 2.1.7 flashrom으로 칩 인식 확인 및 덤프

다음 명령어로 flashrom을 실행해 칩 인식 여부를 확인하고, 펌웨어를 추출한다.

```bash
# 연결 확인 및 Chip 명 확인
sudo flashrom -p linux_spi:dev=/dev/spidev0.0,spispeed=2000 -V
```

정상적으로 인식되면 다음과 같은 메시지가 출력된다.

![image.png](%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2022f1e282ea1580498c93f443493ddb7b/image%201.png)

칩 인식이 되었으면 다음 명령어로 펌웨어를 추출한다.

```bash
# 추출
sudo flashrom -p linux_spi:dev=/dev/spidev0.0 -r [저장파일명]
```

추출을 완료하면 다음과 같은 로그가 출력된다.

```bash
Found Generic flash chip "XM25QH64C" (8192 kB, SPI).
Reading flash... done.
```

이후 생성된 flash.bin 파일은 binwalk 등을 사용해 분석할 수 있다.

**검증(완료 기준)**

- [ ]  flashrom 로그에 **“Reading flash… done”** 표시
- [ ]  추출한 바이너리 파일 크기가 칩 용량과 일치하는지 확인
 (XM25QH64C 기준으로는 약 8 MB가 되어야 덤프 성공)
- [ ]  *(권장)  여러번 덤프 해서 ‘sha256sum flash*.bin’ 값이 일치하는지 확인*

**자주 발생하는 오류 및 해결 방법  (flashrom fail log)**

- `No EEPROM/flash device found`
    
    GND 또는 /CS 접촉 불량 혹은 WP/HOLD 핀을 VCC에 연결하지 않으면 칩 인식에 실패할 수 있다. 이를 해결하기 위해서 GND /CS 핀을 다시 꽂아 확실히 고정되었는지 확인하고 WP/HOLD 핀을 VCC에 연결하여 비활성화 시키면 오류를 해결할 수 있다.
    
- `Permission denied`
    
    SPI 디바이스 권한·sudo 누락이 원인으로 `sudo` 사용 또는 `/dev/spidev0.0` 권한 수정하면 해결이 가능하다.
    

# 2.2 CH341A 활용 펌웨어 추출

- [ ]  칩 데이터 시트 확보
- [ ]  chip-off  (필요 시)
- [ ]  CH341A 롬라이터 + SOP8 클립/어댑터 연결
(CH341A 보드 1 번 ↔ 칩 1 번)
- [ ]  SOP8 클립 장착 & 6 핀(GND /CS CLK MOSI MISO VCC) 배선 확인
- [ ]  USB 드라이버 설치 (`libusb‑dev` 헤더 설치)
- [ ]  USB 패스스루 · 장치 인식 확인 (`lsusb`)
- [ ]  flashrom 설치 완료

## 2.2.1 개요

CH341A 롬라이터를 이용하여 SPI 플래시에서 펌웨어 이미지를 추출하는 과정을 정리한다.

## 2.2.2 플래시 메모리 식별

![image.png](%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2022f1e282ea1580498c93f443493ddb7b/image%202.png)

PCB 기판에서 펌웨어가 저장된 플래시 칩을 확인한다. 

## 2.2.3 플래시 칩‑SOP 보드 연결

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2015.png)

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2016.png)

플래시 칩의 1번 핀(● 실크·홈 표시) 이 SOP 보드의 1번 위치와 일치하도록 후크 클립을 장착하고 1번 위치부터 반시계방향으로 2·3·…·8번 핀도 SOP 보드의 번호와 그대로 대응하도록 연결한다. 

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2017.png)

CH341A 기판 뒷면에 인쇄된 “25” / “24” 표기는 Flash 메모리 시리즈 규격을 나타낸다.

- 25 시리즈 = SPI NOR/NAND 플래시 (W25Q128JV, MX25L6406E 등)
- 24 시리즈 = I²C EEPROM ( 24LC256 등)

본 실습의 대상은 25 시리즈이므로 SPI 핀아웃(3.3 V, GND, MOSI, MISO, CLK, /CS)에 SOP 보드를 연결한다.

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2018.png)

SOP 보드를 연결 하고 레버를 눕혀 고정한다. 

## 2.2.4 PC 연결 및 USB 패스스루

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2019.png)

CH341A를 USB 포트에 꽂으면 아래와 같이 장치가 인식된다.

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2020.png)

본 실습에선 VMware를 사용해서 진행하였으며 “Connect to a virtual machine” 를 선택해 게스트 OS로 패스스루하였다. 

## 2.2.5 Flashrom 활용 메모리 덤프

```bash
sudo apt update
sudo apt install libusb-1.0-0-dev     # USB 프로그래머 지원용 헤더/라이브러리

git clone https://github.com/flashrom/flashrom
cd flashrom
sudo meson setup builddir
sudo meson compile -C builddir
sudo meson test -C builddir
sudo meson install -C builddir
sudo flashrom --programmer ch341a_spi --read flash.bin
```

USB 프로그래머 모듈 컴파일에 필요한 libusb‑dev 헤더를 설치하고 Flashrom을 빌드한다.

이 과정에서 오류가 발생한다면 체크아웃 후 재빌드한다.  

```bash
git checkout v1.5.1
meson setup builddir --reconfigure
```

![image.png](2%20%E1%84%91%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%8E%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%AF%2023e1e282ea1580c699b7c85145f543e0/image%2021.png)

최종적으로 추출된 펌웨어 이미지가 저장된 것을 확인하였으며 추출에 성공하였다.

**검증(완료 기준)**

- [ ]  flashrom 로그에 **“Reading flash… done”** 표시
- [ ]  추출한 바이너리 파일 크기가 칩 용량과 일치하는지 확인
 (XM25QH64C 기준으로는 약 8 MB가 되어야 덤프 성공)
- [ ]  *(권장)  여러번 덤프 해서 ‘sha256sum flash*.bin’ 값이 일치하는지 확인*

**자주 발생하는 오류 및 해결 방법**  

- WSL에서는 USB 장치를 직접 인식하지 못하므로 CH341A 사용이 어렵다. 따라서 VMware / VirtualBox 또는 네이티브 리눅스 환경을 권장한다.
- libusb-dev 헤더를 설치하고 flashrom을 빌드할 때 ____ 오류가 발생할 수 있다. 이 때 체크아웃(git checkout) 후 재빌드하면 해결된다.