# 동적 파트 삭제 내용 백업

### 4.2.1 용어 및 디렉토리 구분 정리  - 동적 링킹 gdbserver 내용을 서술하지 않음에 따라 필요성이 떨어진다고 생각하여 삭제

두 개의 파일 시스템 이미지와 그에 따른 마운트 디렉토리를 사용한다.

각 용어는 다음과 같이 정의한다.

| 구분 | 파일 이름 | 설명 | 마운트 디렉토리 |
| --- | --- | --- | --- |
| QEMU용 파일 시스템 | `rootfs2.ext4` |  직접 생성하여 QEMU에 올릴 파일 시스템이다.  | `qemu_rootfs/` |
| Buildroot에서 자동 생성된
파일 시스템 | `rootfs.ext2` | Buildroot 빌드 시 자동 생성된 파일 시스템이다.
 여기서 `gdbserver`와 필요한 라이브러리들을 추출한다. | `rootfs_buildroot/` |
- `rootfs2.ext4` ← 실제 사용할 파일 시스템 (QEMU 부팅 시 사용)
- `rootfs.ext2` ← 참고용 파일 시스템 (gdbserver 추출용)

> 각 파일 시스템을 사용하기 전에 반드시 마운트 디렉토리를 생성하고 `-o loop` 옵션으로 마운트한다.
마운트한 파일 시스템은 작업이 끝난 후 반드시 `umount` 해야 한다.
> 

- 동적 링킹 gdbserver 내용을 서술하지 않음에 따라 필요성이 떨어진다고 생각하여 삭제

### 4.2.4 파일 시스템에 `gdbserver`추가 - 동적 링킹 gdbserver 내용을 서술하지 않음에 따라 필요성이 떨어진다고 생각하여 삭제

펌웨어에서 추출한 파일 시스템에는 기본적으로 `gdbserver`가 포함되어 있지 않기 때문에, QEMU 환경에서 동적 분석을 하기 위해 `gdbserver`를 수동으로 추가해주어야 한다.

이를 위해 Buildroot에서 `gdbserver`를 포함하도록 설정하여 빌드하면, `output`디렉토리에 `vmlinux`와 함께 파일 시스템 이미지가 생성된다.

이 중 `rootfs.ext2` 파일 시스템의 `/usr/bin/`경로에 `gdbserver` 실행 파일이 포함되어 있다. 

해당 `gdbserver`파일을 추출하여 앞서 만든 QEMU용 파일 시스템에 복사해서 사용한다.

1. **`rootfs.ext2` 마운트**

```bash
mkdir temp
sudo mount -o loop rootfs.ext2 temp
cd temp
```

> `rootfs.ext2`는 Buildroot에서 자동 생성된 파일 시스템 이미지이다.
> 

1. **`gdbserver` 위치 확인**

![image (5).png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image_(5).png)

 

1. **`gdbserver` 파일 복사**

이제 QEMU에서 사용할 파일 시스템(`qemu_rootfs`) 디렉토리에 복사한다.

```bash
# gdbserver를 복사하기 위해 rootfs2.ext4를 다시 마운트
sudo mount -o loop rootfs2.ext4 qemu_rootfs/

sudo cp rootfs_buildroot/temp/usr/bin/gdbserver qemu_rootfs/usr/bin/
```

> 임의로 usr/bin 경로에 복사한 것이고 /bin 경로에 복사해도 상관없다.
> 

1. **마운트 해제**

```bash
sudo umount temp
```

---

### 4.2.5 동적 링커 및 공유 라이브러리 추가 - 동적 링킹 gdbserver 내용을 서술하지 않음에 따라 필요성이 떨어진다고 생각하여 삭제

Buildroot에서 빌드한  `gdbserver`는 정적 링크된 실행 파일이 아니라, 동적 링커와 공유 라이브러리에 의존하는 동적 실행 파일이다.

따라서 `gdbserver` 만 QEMU에 복사하면 안되고 `gdbserver`의 동적 링커와 공유 라이브러리까지 같이 복사를 해줘야 한다.

1. **`gdbserver`의 동적 링커 확인**

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/90223bb6-c686-4694-b328-02df2a31daa9.png)

→ `/lib/ld-uClibc.so.0` 이라는 동적 링커가 필요하다.

1. **`/lib/ld-uClibc`파일의 링커 및 라이브러리 확인**

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image.png)

`ld-uClibc.so.0 → ld-uClibc.so.1 → ld-uClibc-1.0.12.so` 링크 되어 있음을 확인한다.

1. **동적 링커 충돌 방지**

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image%201.png)

`qemu_rootfs/lib` 에는 이미 다른 버전의 링커(`ld-uClibc.so.0 → ld-uClibc-0.9.33.2.so`)가 존재하기 때문에, 단순히 복사하면 커널 패닉 혹은 실행 충돌이 발생할 수 있다.

patchelf 를 이용해 `gdbserver`의 동적 링커 경로를 새로 설정한다. `ld-uClibc.so.0` 가 중복되는 상황이므로 `ld-uClibc.so.0`에서 `ld-uClibc.so.1`로 변경해준다.

```bash
sudo apt install patchelf
sudo patchelf --set-interpreter /lib/ld-uClibc.so.1 qemu_rootfs/usr/bin/gdbserver
```

`ld-uClibc.so.0 → [uClibc-0.9.33.2.so](http://uClibc-0.9.33.2.so)`

1. **`gdbserver`실행을 위한 공유 라이브러리 복사**

```bash
# 링커 관련 복사
sudo cp ld-uClibc-1.0.12.so ../../qemu_rootfs/lib/
sudo cp -a ld-uClibc.so.1 ../../qemu_rootfs/lib/

# 기타 공유 라이브러리 복사
sudo cp -a libuClibc-1.0.12.so ../../qemu_rootfs/lib/
sudo cp -a libc.so.1 ../../qemu_rootfs/lib/
sudo cp -a libdl* ../../qemu_rootfs/lib/
```

참고 : 아래는 복사한 후의 디렉토리 모습이다.

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image%202.png)

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/68ceb84e-2ca4-46df-a6d6-3319311598ba.png)

1. **마운트 해제**

```bash
sudo umount qemu_rootfs
```

1. **ext4 파일 시스템의 저널링 제거** 

ext4 파일 시스템은 기본적으로 저널링 기능이 활성화되는데, 일부 커널은 이 기능을 지원하지 않아 커널 패닉이 발생할 수 있다. 따라서 아래 명령으로 미리 저널링을 제거해준다.

```bash
sudo tune2fs -O ^has_journal rootfs2.ext4
sudo e2fsck -f rootfs2.ext4
```

- `^has_journal` : 저널링 기능 제거
- `e2fsck` : 파일 시스템 무결성 검사 및 복구

## 윗 문단에서 정적 gdbserver 추가 내용을 서술함에 따라 필요성이 떨어진다고 판단하여 삭제

1. **FirmAE의 gdbserver.mipsel 을 이용한 방법**

FirmAE에서 사용하는 gdbserver를 확인해보면 다음과 같이 정적 링킹된 gdbserver를 사용하는 것을 알 수 있다.

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image%203.png)

FirmAE의 gdbserver.mipsel을 기존의 파일 시스템인 rootfs.ext4의 /usr/bin에 위치시키고 실행권한을 부여한다.

```python
sudo chmod +x /home/jm/WHS_Embeded/qemu_rootfs/usr/bin/gdbserver.mipsel
```

이후 4.3.1의 1~5를 동일하게 수행해주면  다음과 같이 실행된다.

![image.png](%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8C%E1%85%A5%E1%86%A8%20%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A1%E1%86%A8%E1%84%8C%E1%85%A6%20%E1%84%82%E1%85%A2%E1%84%8B%E1%85%AD%E1%86%BC%20%E1%84%87%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%A5%E1%86%B8%2023f1e282ea1580488ae8fef51b11bf37/image%204.png)