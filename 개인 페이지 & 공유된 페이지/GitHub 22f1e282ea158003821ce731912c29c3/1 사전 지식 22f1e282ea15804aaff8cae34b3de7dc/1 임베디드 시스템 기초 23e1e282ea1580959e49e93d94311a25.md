# 1. 임베디드 시스템 기초

본 문서에서는 소형 임베디드 기기 펌웨어 분석에 필요한 핵심 개념을 정리한다. 이를 통해 임베디드 시스템과 펌웨어 구조를 명확히 이해하고, 후속 문서에서 다룰 펌웨어 추출·분석 과정을 원활히 수행하기 위한 기반을 마련하고자 한다. 

# 1.1 임베디드 시스템(Embedded System)

임베디드 시스템은 특정 기능을 수행하도록 설계된 전용 컴퓨터 시스템이다. 일반적인 범용 컴퓨터(PC)와는 달리, 제한된 자원(CPU, 메모리 등)을 가지고 한 가지 목적을 안정적으로 수행하는 데 중점을 둔다. 이러한 기기들은 주로 SoC(System on Chip)를 중심으로 구성되며, 이를 제어하는 핵심 소프트웨어인 펌웨어가 함께 탑재된다. 펌웨어는 부팅 과정, 기본 설정, 사용자 데이터 등 다양한 정보를 담고 있기 때문에 임베디드 해킹 및 취약점 분석 과정에서 가장 먼저 확보해야 할 대상이다.

| 항목 | 임베디드 시스템 | 범용 컴퓨터 |
| --- | --- | --- |
| 목적 | 특정 기능 전용 | 다양한 기능 수행 |
| 자원 | 제한적 (저전력, 저용량) | 고성능 자원 |
| OS | 경량화된 OS 또는 비OS | 범용 OS (Windows, Linux 등) |

**펌웨어 구성**

펌웨어는 임베디드 시스템에 내장되어 하드웨어를 제어하고 소프트웨어와의 연결을 담당하는 핵심 소프트웨어이다. 일반적으로 펌웨어는 플래시 메모리에 저장된다. 펌웨어는 대체로 SoC, 부트로더, 커널, 루트 파일 시스템의 구조를 가진다.

![image.png](1%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%87%E1%85%A6%E1%84%83%E1%85%B5%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%2023e1e282ea1580959e49e93d94311a25/image.png)

### 1.1.1 SoC(System of Chip)

SoC는 CPU, GPU, 메모리 컨트롤러, I/O 포트 등을 하나의 칩에 탑재한 구조로, 기기의 성능 및 기능 구현에 핵심적인 역할을 한다. SoC 내부에 존재하는 BootROM은 전원 인가 직후 가장 먼저 실행되어 외부 플래시에서 부트로더를 읽어오고, 이후 이 부트로더는 2차 부트로더나 OS 커널을 로드한다. 따라서 SoC 아키텍처와 동작 방식을 정확히 파악하면 펌웨어 동적 분석 환경을 구축하는 데 필요한 정보를 확보할 수 있다.

![image.png](1%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%87%E1%85%A6%E1%84%83%E1%85%B5%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%2023e1e282ea1580959e49e93d94311a25/image%201.png)

### 1.1.2 부트로더(Bootloader)

부트로더는 SoC의 BootROM이 가장 먼저 호출하는 프로그램이다. 대표적인 부트로더로는 U-Boot가 있으며, 메모리 초기화, 커널 로드, 환경 변수 설정 등을 담당한다. 부트로더는 다음과 같은 단계로 구성된다.

1. SPL(Secondary Program Loader) : 제한된 ROM 환경에서 작동하는 최소 부트로더로, 메모리 초기화, 메인 부트로더 로드 등을 수행한다.
2. U-Boot(Main Bootloader) : 부트 환경 설정, 커널/디바이스 트리 로딩, 명령어 인터페이스 제공한다
    
    ![image.png](1%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%87%E1%85%A6%E1%84%83%E1%85%B5%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%2023e1e282ea1580959e49e93d94311a25/image%202.png)
    

부트로더 접근이 가능하면 U-Boot 환경 변수를 수정으로 루트 셸을 획득할 수 있으며, 이를 통해 다양한 공격 및 분석을 수행할 수 있다.

### 1.1.3 커널(Kernel)

커널은 운영체제의 중심 구성 요소로, 사용자 공간에서 실행되는 프로그램이 하드웨어를 직접 제어하지 않고, 커널을 통해 간접적으로 자원을 사용하게 함으로써 접근 통제 및 권한 분리를 통해 시스템 보안을 강화한다. 장치 드라이버, 메모리 관리, 파일 시스템 등의 저수준 기능을 직접 제어하며, 시스템 자원을 효율적으로 관리한다.

![image.png](1%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%87%E1%85%A6%E1%84%83%E1%85%B5%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%2023e1e282ea1580959e49e93d94311a25/image%203.png)

사용자가 CLI(명령어 인터페이스)에서 명령을 입력하면, 해당 명령은 먼저 셸(Shell) 에 전달된다. 셸은 이 명령어를 커널이 이해할 수 있는 시스템 호출(System Call)로 변환하여 커널에 전달하고, 커널은 이를 처리해 하드웨어를 제어하거나 필요한 작업을 수행한 뒤, 그 결과를 다시 사용자에게 출력한다. 

### 1.1.4 루트 파일 시스템(Root File System, RootFS)

루트 파일 시스템은 사용자 공간(user space)을 구성하는 데 필요한 실행 파일, 설정 파일, 라이브러리 등 핵심 요소들이 위치한 기본 파일 시스템이다. 이 파일 시스템은 커널 부팅 이후 가장 먼저 마운트되어 운영체제가 동작하기 위한 최소한의 사용자 공간 환경을 제공한다.

루트 파일 시스템에는 다음과 같은 주요 디렉토리가 포함된다.

| 디렉토리 | 설명 |
| --- | --- |
| `/bin` | 시스템 부팅 및 기본 명령어 실행에 필요한 바이너리 파일 |
| `/etc` | 시스템 설정 파일 |
| `/lib` | 기본 실행 파일이 사용하는 공유 라이브러리 |
| `/usr` | 응용 프로그램, 라이브러리, 문서 등 부가적인 사용자 공간 구성 |
| `/dev`, `/proc`, `/sys` | 장치 파일 및 가상 파일 시스템 (커널 인터페이스) |

커널은 자체적으로 사용자 명령을 처리할 수 없기 때문에, 루트 파일 시스템이 마운트되어야 `/sbin/init` 과 같은 초기화 프로세스를 실행할 수 있다. 따라서 커널이 부팅된 직후 가장 먼저 마운트되는 파일 시스템이 루트 파일 시스템이다.

루트 파일 시스템으로 데 사용되는 파일 시스템은 여러 가지 형식이 있다. 아래는 임베디드 시스템에서 자주 사용되는 파일 시스템이다.

- `ext2/ext3/ext4` : 리눅스에서 가장 널리 사용되는 디스크 기반 파일 시스템이다. ext4는 저널링, 대용량 지원, 빠른 성능을 제공하여 QEMU 테스트용 루트 파일 시스템으로 자주 사용된다.
- `squashfs` : 읽기 전용(Read-Only) 압축 파일 시스템이다. 크기를 최소화할 수 있어 펌웨어 내 루트 파일 시스템으로 자주 사용된다.
- `jffs2`: 저널링 플래시 파일 시스템 버전 2이다. 플래시 메모리 장치에 쓰이는 리눅스 로그 구조 파일 시스템이다. 파일이나 디렉터리에 대한 변경 사항이 일종의 로그로서 노드에 기록된다.

# 1.2 플래시 메모리(Flash Memory)

플래시 메모리는 비휘발성 저장장치로, 전원이 꺼져도 데이터를 보존할 수 있다. 임베디드 시스템에서는 펌웨어 저장 공간으로 사용된다.

![image.png](1%20%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%87%E1%85%A6%E1%84%83%E1%85%B5%E1%84%83%E1%85%B3%20%E1%84%89%E1%85%B5%E1%84%89%E1%85%B3%E1%84%90%E1%85%A6%E1%86%B7%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%2023e1e282ea1580959e49e93d94311a25/image%204.png)

# 1.3 분석 방법

## 1.3.1 정적 분석

정적 분석은 펌웨어를 실행하지 않고 파일 수준에서 구조와 코드를 분석하는 방법이다. Binwalk와 같은 도구를 활용하여 바이너리와 리소스를 추출한 뒤 Ghidra와 IDA Pro 같은 디스어셈블러나 디컴파일러로 함수 흐름을 추적한다. strings, objdump, file 같은 기본 유틸리티를 사용해 연관 텍스트와 아키텍처를 확인하기도 한다. 정적 분석은 실행 위험이 없어 악성 동작으로부터 안전하며, 전체 코드 범위를 한눈에 살펴 취약 함수나 하드코딩된 암호·인증서 같은 정적 아티팩트를 빠르게 찾을 수 있다는 이점을 갖는다. 

## 1.3.2 동적 분석

동적 분석은 에뮬레이터 또는 실제 하드웨어에서 펌웨어를 실행하며 런타임 동작을 관찰·제어하는 방식이다. 여기서 에뮬레이터란 호스트와 다른 CPU 아키텍처의 환경을 소프트웨어적으로 구현함으로써 다른 아키텍처에서 작성된 펌웨어를 실행할수 있게 해 주는 소프트웨어를 말한다. 분석 대상 기기와 분석용 워크스테이션의 아키텍처가 다를 때도 코드 수정 없이 동작을 재현할 수 있고, 스냅샷, 중단(Breakpoint), 메모리 덤프 같은 조작이 자유롭다는 이점을 갖는다. 범용 오픈소스 CPU 에뮬레이션 프레임워크 QEMU가 가장 널리 사용되고 있으며, 추가적으로 GDB, strace, Wireshark, tcpdump와 같은 디버깅·트래픽 분석 도구를 함께 사용해 메모리, 네트워크, 시스템 이벤트를 실시간으로 수집하기도 한다.